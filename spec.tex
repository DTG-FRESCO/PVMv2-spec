%%%% University of Cambridge tech-report formatting; enable when producing
%%%% tech-report versions of these documents; otherwise, disable.
\documentclass[12pt,twoside,a4paper]{article}
\setlength{\oddsidemargin}{-0.4mm} % 25 mm left margin
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textwidth}{160mm}      % 25 mm right margin
\setlength{\topmargin}{-5.4mm}     % 20 mm top margin
\setlength{\headheight}{5mm}
\setlength{\headsep}{5mm}
\setlength{\footskip}{10mm}
\setlength{\textheight}{237mm}     % 20 mm bottom margin
%%%% .. or regular document
%\documentclass[12pt,letterpaper,twoside,openright,fleqn]{report}
%%%% End of tech-report vs. regular
%%%%

\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tikz-uml}
\usepackage[hidelinks]{hyperref}

\newcommand{\Entity}{\hyperref[sec:ty:entity]{Entity}}
\newcommand{\para}[1]{\paragraph{#1\\}}

\begin{document}
\title{PVMv2 Specification}
\author{Thomas Bytheway \and Lucian Carata}

\maketitle

\clearpage

\section{Introduction}
PVMv2 is a model designed to aid in the extraction of high level data flow interactions from low level event traces. It achieves this by using descriptive mapping programs written in a custom DSL by people who understand the semantic content of the event trace in question. This mapping can then be applied to actual trace events and results in the iterative production of a dataflow graph.

This document aims to describe the conceptual basis behind the PVMv2 model, explain how the resulting dataflow graph is structured and what assumptions can be made about it, and how one would go about creating a mapping to interpret new data under the guise of the PVMv2 model.

\section{Abstract Types}
\label{sec:ty}
The PVMv2 model defines a number of different abstract types which are used to both represent data in the resulting graph format, and as a basis for deriving concrete types to represent real trace entities. Figure~\ref{fig:types} shows a UML representation of the different types and how they are related. Below we will go into more detail on each of the types in turn.

\begin{figure}[h]
\centering
\input{types_fig}
\caption{A diagram of the basic abstract types in PVMv2}
\label{fig:types}
\end{figure}

\para{Entity}
\label{sec:ty:entity}
 is the root abstract type. The common feature of all entities is that they possess a uniquely identifying name that is either totally unique for some subtypes, or is maintained for version chains for other subtypes. In general concrete types should not be derived from Entity unless there is no better option available.

\para{Actor}
\label{sec:ty:actor}
 entities are active entities that perform actions, generally processing units such as unix processes, though they can also represent more abstract notions of processing. They are directly comparable to subjects in the orange book. They act upon objects, or other actors.

\para{Object}
Passive entities that are acted upon by actors. Generally data carrying entities.

\para{Store}
Object type that stores data internally. Versions from first write to last write, using EditSessions.

\para{ChannelEP}
Object type that data flows through without internal storage. Does not version. May participate in connections.

\section{Graph Schema}
In this section we will describe how a well formed PVMv2 graph will appear. This does not necessarily inform directly how an encoding of such a graph may appear in a given medium, but should be taken as a strong suggestion of how it will be structured. In \autoref{app:enc:neo4j} we describe the encoding of such graphs in Neo4j and in \autoref{app:enc:cdm} their encoding into CDM.

\subsection{Nodes}

\begin{figure}[h]
\centering
\input{nodes_fig}
\caption{A diagram of the potential nodes in a PVMv2 database.}
\end{figure}

\subsubsection{Schema Nodes}
Schema nodes describe concrete types that are defined by the mapping that created a database. Each node has a name of the type being defined, an abstract type that the concrete type is a class of, and a list of potential properties that it is valid for a node of that type to have.

\subsubsection{Context Nodes}


\subsubsection{Entity Nodes}
Entity nodes represent an \Entity~of an abstract type in the graph, they can be additionally subclassed into the abstract types as defined earlier. All entity nodes have a \field{uuid}~field defining the unique name for the entity, a \field{ty}~field naming the concrete type that the entity is a representative of, and a \field{ctx}~field noting the context under which the entity was created.

\subsubsection{Non-canonical Names}

\para{Path Names}

\para{Network Addresses}

\subsection{Relations}

\begin{figure}[h]
\centering
\input{rel_fig}
\caption{A diagram of the potential relations in a PVMv2 database.}
\end{figure}

\para{INF}
Indicates that the source has potentially imparted data or control to the destination.

\para{NAMED}
Indicates that the source has been mentioned by the destination non-canonical name.

\section{Mappings}

\subsection{Concrete Type Declaration}

\subsection{Verbs}

\para{Declare}
Forces the creation of entity if it does not already exist.

\para{Sink}
Called when as part of a mapped function, an actor sinks data to an entity as an ‘atomic’ operation.
Causes Stores to version, creating a new Store entity connected to the previous one by an INF relation.
Creates an INF relation from actor to entity. 

\para{Source}
Called when as part of a mapped function, an actor sources data from an entity.
Creates an INF relation from entity to actor.

\para{Connect}
Called as part of a mapped function to declare that two channel nodes are connected to each other and that data can flow between them. The dir argument indicates the direction of flow, either mono or bi. Mono indicates that data may only flow from the first channel to the second, bi indicates that data may flow in both directions. 

\para{Mention}

\para{Unlink}

\para{Property}

\appendix

\section{A Worked Example}

\section{Neo4j Encoding}
\label{app:enc:neo4j}

\section{CDM Encoding}
\label{app:enc:cdm}

\end{document}
